"""
requests script, using sample-metadata api
takes family IDs, and returns a dictionary of family: [sampleID,]
output is designed for the trio extraction script,
shlex escaping is required for correct running on dataproc/hail batch

by default sample IDs are CPG internal IDs; by flag these can be external

output is intended for MatrixTable sub-setting script within this directory
"""


import json
import subprocess
from csv import DictReader
from io import StringIO
from shlex import quote
from typing import Tuple

import click
import pandas as pd
import requests


def get_auth() -> str:
    """
    uses a shell to execute the auth token grab
    :return: str: the token generated by the gcloud process

    This will only work as a locally executed script
    """
    return (
        subprocess.check_output(['gcloud', 'auth', 'print-identity-token'])
        .decode()
        .strip()
    )


def get_response(url, headers, query_params=None) -> requests.Response:
    """
    perform the actual execution of the URL with provided parameters
    :param url: str
    :param headers: dict
    :param query_params: [optional] dict
    :return: requests.Response
    """

    resp = requests.get(headers=headers, url=url, params=query_params)

    # raise exception if `not resp.ok`
    resp.raise_for_status()

    return resp


def get_family_to_sample_map(
    df: pd.DataFrame,
    families: Tuple[str],
    external: bool,
    pid_to_id: dict,
    int_to_ext: dict,
) -> dict:
    """
    take families from cli input; for each find all sample IDs. Return as a JSON dict
    :param df: the pedigrees dataframe
    :param families: Tuple[str], containing family ID strings
    :param external: bool, True to return external sample IDs, false for CPG IDs
    :param pid_to_id: dict, lookup of int. participant ID to int. sample ID
    :param int_to_ext: dict, lookup of int. sample ID to external

    NOTE; this is all assuming a single participant-sample connection in the API results
    """

    dict_result = {}  # type: ignore

    for family_id in families:

        dict_result[family_id] = []

        # isolate all rows containing the family members from the pedigree table
        members_df = df.loc[df['Family ID'] == family_id]
        original_ids = {row['Individual ID'] for index, row in members_df.iterrows()}

        # translate those IDs to something usable
        for member_id in original_ids:

            # participant to internal sample
            sample_id = pid_to_id.get(member_id)

            # do we want the external IDs instead?
            if external:
                sample_id = int_to_ext.get(sample_id)

            dict_result[family_id].append(sample_id)

    return dict_result


@click.command()
@click.option(
    '--project',
    'project',
    type=click.STRING,
    help='the name of the project to use in API queries',
)
@click.option(
    '-f',
    '--families',
    'families',
    type=click.STRING,
    multiple=True,
    help='one or more family IDs to search for',
)
@click.option(
    '--external',
    'external',
    type=click.BOOL,
    default=False,
    is_flag=True,
    help='if this is set, return external IDs instead',
)
@click.option(
    '--auth',
    'auth_token',
    type=click.STRING,
    default='NOT_PROVIDED',
    help='A JWT for user authentication',
)
def main(project: str, families: Tuple[str], external: bool, auth_token: str):
    """
    main process, using click args
    """

    if auth_token == 'NOT_PROVIDED':
        auth_token = get_auth()

    # currently the 2 types of endpoint require different headers, with the same auth token
    bearer_token = f'Bearer {auth_token}'
    table_header = {'Accept': ACCEPT_ALL, 'Authorization': bearer_token}
    mapping_header = {'Accept': ACCEPT_JSON, 'Authorization': bearer_token}

    # core query params from documentation
    # get the pedigrees across the entire project
    response = get_response(
        url=f'{URL_BASE}/{FAMILY_ENDPOINT}/{project}/{PEDIGREE}',
        headers=table_header,
        query_params={
            'replace_with_participant_external_ids': True,
            'replace_with_family_external_ids': True,  # False
            'empty_participant_value': '',
            'include_header': True,
        },
    )

    # parse this into a series of dictionaries, then into a dataframe
    dict_read = DictReader(
        StringIO(response.content.decode().strip('#')), delimiter='\t'
    )
    pedigree_df = pd.DataFrame(list(dict_read))

    # -#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#- #
    # so now we have a dataframe of the entire pedigree structure
    # NOTE - this is just a hack around, with examples of further hackery

    # # example queries on pedigree_df - all affected females
    # aff_females = pedigree_df.loc[(pedigree_df['Affected'] == '2') & (pedigree_df['Sex'] == '2')]
    #
    # # all members of those families
    # aff_female_fams = df.loc[df['Family ID'].isin(aff_females['Family ID'].values)]
    #
    # # are there any affected parents? - affected and not 'proband'
    # aff_parents = pedigree_df.loc[
    #   (pedigree_df['Affected'] == '2') &
    #   (~pedigree_df['Individual ID'].str.contains('proband')),
    #   ['Family ID', 'Individual ID']
    # ]
    # -#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#- #

    # we can obtain a lookup on the internal sample ID using the external PID
    # participant/acute-care/external-pid-to-internal-sample-id # JSON
    # this will get us a CPG ID (INTernal, not INTeger)
    response = get_response(
        url=f'{URL_BASE}/{PARTICIPANT_ENDPOINT}/{project}/external-pid-to-internal-sample-id',
        headers=mapping_header,
    )
    paired_samples_list = response.json()
    pid_to_sample_id = dict(
        zip([_[0] for _ in paired_samples_list], [_[1] for _ in paired_samples_list])
    )

    # we can then map the internal sample IDs to external sample IDs
    # sample/acute-care/id-map/internal/all # JSON
    response = get_response(
        url=f'{URL_BASE}/{SAMPLE_ENDPOINT}/{project}/id-map/internal/all',
        headers=mapping_header,
    )
    internal_to_ext_map = response.json()

    family_to_samples_dict = get_family_to_sample_map(
        df=pedigree_df,
        families=families,
        external=external,
        pid_to_id=pid_to_sample_id,
        int_to_ext=internal_to_ext_map,
    )

    # now print as a string value, with no spaces
    json_formatted = quote(
        json.dumps(
            family_to_samples_dict,
            separators=(',', ':')
        )
    )
    print(json_formatted)


URL_BASE = 'https://sample-metadata-api-mnrpw3mdza-ts.a.run.app/api/v1'
ACCEPT_ALL = '*/*'
ACCEPT_JSON = 'application/json'
FAMILY_ENDPOINT = 'family'
PARTICIPANT_ENDPOINT = 'participant'
SAMPLE_ENDPOINT = 'sample'
PEDIGREE = 'pedigree'


if __name__ == '__main__':
    main()
